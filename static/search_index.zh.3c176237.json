[{"id":0,"title":"","routePath":"/Stack","lang":"zh","toc":[],"domain":"","content":"","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/Stack.md","_relativePath":"zh/Stack.md"},{"id":1,"title":"第13章 排序和搜索算法","routePath":"/guide/book/chap13","lang":"zh","toc":[],"domain":"","content":"#","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/book/chap13.mdx","_relativePath":"zh/guide/book/chap13.mdx"},{"id":2,"title":"第14章 算法设计与技巧","routePath":"/guide/book/chap14","lang":"zh","toc":[{"text":"分而治之","id":"分而治之","depth":2,"charIndex":3}],"domain":"","content":"#\n\n\n分而治之#\n\n分而治之也称分治算法（Divde and\nconquer）是算法设计中一种常用的算法。它是将一个问题拆分成与原问题相似的多个小问题，然后递归解决这些小问题，最后这些小问题的结果进行组合来解决问题。\n\n分治的拆解步骤：\n\n 1. 分解把一个大问题分解成多个子问题\n 2. 解决子问题，用返回子问题的方式的递归算法。递归算法的基本情形可以解决算法\n 3. 组合这些子问题的解决方式，来解决整个的大问题\n\n例子：分治的方法处理二分法查找源码链接\n\nfunction binarySearchRecursive(arr: number[], value: number, low: number, hight: number) {\n  const defaultValue = -1;\n  if (low <= hight) {\n    const mid = Math.floor((hight + low) / 2);\n    if (arr[mid] > value) {\n      return binarySearchRecursive(arr, value, low, mid - 1);\n    } else if (arr[mid] < value) {\n      return binarySearchRecursive(arr, value, mid + 1, hight);\n    } else {\n      return mid;\n    }\n  }\n  return defaultValue;\n}\n\nexport default function binarySearch(arr: number[], value: number) {\n  const sortArr = quickSort(arr);\n  const low = 0;\n  const hight = sortArr.length - 1;\n  return binarySearchRecursive(sortArr, value, low, hight);\n}\n","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/book/chap14.mdx","_relativePath":"zh/guide/book/chap14.mdx"},{"id":3,"title":"第11章 二叉堆与堆排序","routePath":"/guide/book/heap","lang":"zh","toc":[{"text":"堆排序算法","id":"堆排序算法","depth":2,"charIndex":235}],"domain":"","content":"#\n\n二叉堆是一种特殊的二叉树。有以下两个特性：\n\n * 是一棵完整的二叉树，即每个节点（除了最后一层）都是完整的左右节点，并且最后一层的节点尽可能的只有左子节点。这个叫结构特性。\n * 堆特性：即二叉树不是最大堆就是最小堆。\n   * 最大堆，即根节点为最大值的二叉堆\n   * 最小堆，即根节点为最小值的二叉堆\n\n注：二叉堆是二叉树，但是并一定是搜索二叉树。在二叉堆中每个子节点都是大于或者小于父节点。在二叉树中，左侧节点总是小于父节点，右侧节点总是大于父节点。\n\n\n堆排序算法#\n\n因为在二叉堆（最大堆、最小堆）里的数组是二叉树的一种特殊表现形式。即而转换了对于最大堆与最小堆进行排序，步骤如下：","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/book/heap.mdx","_relativePath":"zh/guide/book/heap.mdx"},{"id":4,"title":"第6章 链表","routePath":"/guide/book/linkedList","lang":"zh","toc":[{"text":"种类","id":"种类","depth":2,"charIndex":85}],"domain":"","content":"#\n\n链表是一种物理存储单元上非连续、非顺序的存储结构。数据元素的逻辑顺序通过指针链接实现。链表是由一系列结点组成。 特点是：添加和删除都比较方便。但是访问比较耗时。\n\n\n种类#\n\n链表主要分为以下几种：\n\n * 单向链表\n * 双向链表\n * 循环链表","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/book/linkedList.mdx","_relativePath":"zh/guide/book/linkedList.mdx"},{"id":5,"title":"第9章 递归","routePath":"/guide/book/recursive","lang":"zh","toc":[{"text":"阶乘","id":"阶乘","depth":2,"charIndex":90},{"text":"斐波那契数列","id":"斐波那契数列","depth":2,"charIndex":493},{"text":"记忆化的fibonacci","id":"记忆化的fibonacci","depth":3,"charIndex":1067},{"text":"总结","id":"总结","depth":2,"charIndex":1384}],"domain":"","content":"#\n\n> “要理解递归，首先要理解递归。——佚名\n\n递归：自己调用自己进行解决问题，多在树结构中出现。其核心：找到重复的部分，和跳出的边界条件(也叫基线条件)。两个经典的例子：\n\n\n阶乘#\n\n这个是高中数据的知识点，0的阶乘是1，负数的阶乘不存在 5!(5的阶乘) = 5 x 4 x 3 x 2 x 1 = 120\n\n// 递归\nfunction factorialRecursive(num) {\n  if (num === 0 || num === 1) return 1;\n  if (num < 0) return;\n  return num * factorialRecursive(num - 1);\n}\n\n// 迭代\nfunction factorialIterative(num) {\n  let result = 1;\n  // if(num <= 2) return num;\n  for (let index = 1; index <= num; index++) {\n    result *= index;\n  }\n  return result;\n}\n\n\n\n斐波那契数列#\n\n0 1 1 2 3 5 即后一位为前两位的和\n\n * 位置是0的数列为零\n * 1和2的斐波那契数为1\n * n > 2的数列为： (n -1) + (n - 2)\n\n// 递归\nfunction fibonacciRecursive(num) {\n  if (num < 1) return 0;\n  if (num === 1 || num === 2) return 1;\n  return fibonacciRecursive(num - 1) + fibonacciRecursive(num - 2);\n}\n\n\n// 迭代\nfunction fibonacciIterative(num) {\n  if (num < 1) return 0;\n  if (num === 1 || num === 2) return 1;\n\n  let res = 0;\n  let f1 = 0;\n  let f2 = 1;\n  //   正向迭代 初始化为0，所以迭代次数为：位数 - 1\n  for (let index = 0; index < num - 1; index++) {\n    res = f1 + f2;\n    f1 = f2;\n    f2 = res;\n  }\n\n  return res;\n}\n\n\n\n记忆化的fibonacci#\n\n主要用一个数据进行结果的缓存，memo。减少计算次数，从而提高效率\n\nfunction fibonacciMemoization(n) {\n  const memo = [0, 1]; // {1}\n  const fibonacci = (n, memo) => {\n    if (memo[n] != null) return memo[n]; // {2}\n    return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)); // {3}\n  };\n  return fibonacci(n, memo);\n}\n\n\n\n总结#\n\n * 性能层面 递归和迭代相比并不具有性能优势。有些情况下还不如迭代。\n\n * 优点 代码量少，容读","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/book/recursive.mdx","_relativePath":"zh/guide/book/recursive.mdx"},{"id":6,"title":"介绍","routePath":"/guide/introduction","lang":"zh","toc":[],"domain":"","content":"#\n\nTodo List","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/introduction.mdx","_relativePath":"zh/guide/introduction.mdx"},{"id":7,"title":"学习中的一些知识点","routePath":"/guide/other","lang":"zh","toc":[{"text":"++i与i++的区别","id":"++i与i++的区别","depth":3,"charIndex":3}],"domain":"","content":"#\n\n\n++i与i++的区别#\n\nlet i = 0;\nlet a = i++;\nconsole.log(i); // 1\nconsole.log(a) // 0\n\n\nlet i = 0;\nlet a = ++i;\nconsole.log(i); // 1\nconsole.log(a)  // 1\n\n\n从上面的结果可以看得出来 i++ 是先赋值后运算，而++i为先运算后赋值","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/other.mdx","_relativePath":"zh/guide/other.mdx"},{"id":8,"title":"二进制","routePath":"/guide/system/","lang":"zh","toc":[{"text":"原码、补码、反码","id":"原码、补码、反码","depth":2,"charIndex":128},{"text":"原码","id":"原码","depth":3,"charIndex":214},{"text":"反码","id":"反码","depth":3,"charIndex":568},{"text":"补码","id":"补码","depth":2,"charIndex":778},{"text":"进制转换","id":"进制转换","depth":3,"charIndex":1238},{"text":"js中的位运算符号","id":"js中的位运算符号","depth":2,"charIndex":1490},{"text":"位置移动类","id":"位置移动类","depth":3,"charIndex":2002},{"text":"技巧","id":"技巧","depth":2,"charIndex":2411},{"text":"参考","id":"参考","depth":2,"charIndex":2689}],"domain":"","content":"#\n\njs中的二进制，主要使用Number.toString(radix)，其中的radix表示要转换成多的进制数，默认值为10。\n有ES6中通过添加0b后面添加一系列二进制的数字（0或1），来表示一个二进制数。js中最高位用于表示符号：0为正，1为负\n\n\n原码、补码、反码#\n\n这些知识点，我在有限的脑海里应该是在本科学习《计算机组成原理》时学到的东西。\n\n前提：为了简化问题，二进制都是用一个字节，即8个二进制数来表示。\n\n\n原码#\n\n先来说一说真值，表示自然数（正数、负数、0）以 +1 和 -1用二进制表示\n\n+ 00000001 # +1\n- 00000001 # -1\n\n\n8位二进制能表示的范围为[-2 ^ 8, +2 ^ 8]\n\n由于计算机的二进制只能用0和1进行表示，无法表示正负。所以就有了如下的规矩：取首位为符号为0表示为正；1表示为负，剩下的七位表示真值的绝对值。这种方法叫\n原码表示法。上面的例子 +1和-1表示如下 :\n\n0 0000001 # +1\n1 0000001 # -1\n\n\n思考一下，那100000000 表示什么？ -0。但是-0这个值是没有意义的。 所以规定 10000000\n用来表示-128,这样算下来负数就比正数多了一位，所以二进制的表示范围：[-2 ^7, +2 ^ 7 - 1]\n\n\n反码#\n\n反码是另一种表示数字的方法，规定如下：符号位保持不变，正数的反码就是本身，负数的反码，其余各值取按位反。例子如下：\n\n00000101 反码 01111010\n\n但是为什么会出现反码这个东西呢？正常的计算机只能计算加法，但是遇到负数的时候怎么办？\n\n负数的反码变成了正值，这样就能通过反码把两个负数的运算转换为加法。从而简化问题。引用网上的例子如下（-1 + -2）：\n\n\n\n取负数的反码之后进行运算\n\n\n\n\n补码#\n\n思考一个问题，负数与负数的运算可以解决了，正数与负数的运算也可以正常运算了。但是还有一个问题：在原码中有+0， -0这两个特殊的值，可以在反码中正常运算吗？\n\n\n\n从上面的运算结果来看，反码解决不了这个问题。于是就引出来的补码。\n先来看下补码的定义：符号位保持不变，正数的原码与补码一样，负数的补码，其余按位取反，最后末尾+1（即反码末尾+1）。让我们来看下补码后的所有数：\n\n\n\nOK，解决了-0和+0的问题。所有运算都可以转换成为补码进行运算了. 最后总结下补码的表示区间。\n\n\n\n总结一下：\n\n 1. 原码：能够直接表示数值的大小情况，也是人最容易能理解的一类计算表示数。首位为符号位：0代码正、1代表负\n 2. 反码：是一个过渡码，正数的反码就是本身，负数的反码为：符号为保持不变，其余按位取反\n 3. 补码：是计算机中存储数值的形式，解决了负数加法的问题，使得符号位直接参与运算。\n\n注：在一些位运算的题中要注意数范围是否有符号数，在js中可以用>>>0的方式，把一个数值转换为无符号为的形式。\n\n\n进制转换#\n\n * 十进制转换为k进制。主要通过，除以 k ，右侧为余数，最终的结果为：从下到上，高位到低位进行转换。如下图：\n\n\n\n * 二进制转换为十进制\n\n101转换为十进制：从右往左进行实现(^表示次方的意思)\n\n1 x 2 ^ 0 = 1\n\n0 x 2 ^ 1 = 0\n\n1 x 2 ^ 2 = 4\n\n--------------------------------------------------------------------------------\n\n即：4 + 1 = 5\n\n\njs中的位运算符号#\n\n * | 或\n\n> | 逻辑或运算：\n> \n>  1. 如果都为0，则返回0\n>  2. 运算中两位数其中有一个为1，则为1\n\n    101\n    001\n=   101\nconsole.log((0b101 | 0b001).toString(2)); # 101\n\n\n * & 与\n\n&运算的规律如下：如果都为1则为1，运算中有一个为0，则为0\n\n    101\n    001\n=   001\n\n(0b101 & 0b011).toString(2) # 1\n\n\n * ^ 异或\n\n异或，就是比较两个数是否相同，相同则为0，不同则为1\n\n\n    101\n    001\n=   100\n\n(0b101 ^ 0b001).toString(2) # 100\n\n\n总结： ^和|都可以用于把一个二进制第i位数字还原到对应的位置中去\n\n * ~ 非\n\n·~·运算符，则会对每一位进行取反，1变为0， 0变为1\n\n    101\n=   010\n\n(~0b101).toString(2) # -110\n# 这里返回的结果为 -110,是因为最高为符号默认为 0，取反后为1，就变成了负数\n\n\n\n位置移动类#\n\n * << 左移\n\n1 << i,表示把一个二进制数的第i位值\n\nt |= 1 << i表示的意思是把第i位的二进制值还到数字t的第i位中\n\n左移：就是每一位都向左移动一位，尾数补0，基效果相当于x2，其实计算机就是使用移位来进行乘法计算的。\n\n(0b010 << 1).toString(2) // 100\n\n\n * >> 右移（有符号右移）\n\n右移：向右移动 n 位，右边的值被丢弃。左边空位值使用符号位的数值进行补充\n\n常见操作 n >> i 这个操作是用于在n的二进制中取第i位的值从左到右。即 (n >> i) & 1可以判断当前为是 1还是0\n\n * >>> 逻辑右移（无符号右移）\n\n> 该运算符将第一个操作数向右移动指定的位数。向右移动的多余位将被丢弃。零位从左侧移入。其符号位变为\n> 0，因此其表示的结果始终为非负数。与其他按位运算符不同，零填充右移返回无符号 32 位整数。\n\n\n技巧#\n\n * js中使用toString(2) 把一个数转换为指定进制数\n\n * 移除二进制数中右侧的最后一个1 n & (n-1)\n\n * 获取最后一个1也叫LowBit，有两个公式\n   \n   * x & -x\n   * n &(n ^ (n - 1))\n\n * 使用位运算来判断一个数字是奇数还是偶数，注意是 ==并不是严格等于。\n\n> i & 1 == 1 为奇数\n> \n> i & 1 == 0 为偶数\n> \n> 因为在二进制中奇数的最后一位肯定不是0，一个数 %2有余数才为奇数。而十进制转换为二进制的过程最后的试算正是用的%2的余数\n\n\n参考#\n\n 1.  https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html\n 2.  http://graphics.stanford.edu/~seander/bithacks.html#OperationCounting\n 3.  https://www.51cto.com/article/663685.html\n 4.  https://xiaochen1024.com/courseware/60b4f11ab1aa91002eb53b18/6196420ac1553b\n     002e57bf19\n 5.  https://developer.aliyun.com/article/841237\n 6.  https://yanhaijing.com/javascript/2016/07/20/binary-in-js/\n 7.  https://segmentfault.com/a/1190000038208382\n 8.  https://www.cnblogs.com/fusiwei/p/11752540.html\n 9.  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators\n 10. js中位运算的骚操作","frontmatter":{},"_filepath":"/home/runner/work/leet-code/leet-code/docs/zh/guide/system/index.mdx","_relativePath":"zh/guide/system/index.mdx"}]