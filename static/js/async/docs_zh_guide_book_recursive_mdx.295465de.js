(self.webpackChunkleet_code=self.webpackChunkleet_code||[]).push([["docs_zh_guide_book_recursive_mdx"],{88331:function(n,e,i){"use strict";i.r(e),i.d(e,{default:function(){return t}});var r,c=i("20040"),s=i("5371");function a(n){var e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",pre:"pre",ul:"ul",li:"li",h3:"h3"},(0,s.useMDXComponents)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"第9章-递归",children:[(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第9章-递归",children:"#"}),"第9章 递归"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"“要理解递归，首先要理解递归。——佚名"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"递归：自己调用自己进行解决问题，多在树结构中出现。其核心：找到重复的部分，和跳出的边界条件(也叫基线条件)。两个经典的例子："}),"\n",(0,c.jsxs)(e.h2,{id:"阶乘",children:[(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#阶乘",children:"#"}),"阶乘"]}),"\n",(0,c.jsxs)(e.p,{children:["这个是高中数据的知识点，0的阶乘是",(0,c.jsx)(e.code,{children:"1"}),"，负数的阶乘不存在\n5!(5的阶乘) = 5 x 4 x 3 x 2 x 1 = 120"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",meta:"",children:"// 递归\nfunction factorialRecursive(num) {\n  if (num === 0 || num === 1) return 1;\n  if (num < 0) return;\n  return num * factorialRecursive(num - 1);\n}\n\n// 迭代\nfunction factorialIterative(num) {\n  let result = 1;\n  // if(num <= 2) return num;\n  for (let index = 1; index <= num; index++) {\n    result *= index;\n  }\n  return result;\n}\n"})}),"\n",(0,c.jsxs)(e.h2,{id:"斐波那契数列",children:[(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#斐波那契数列",children:"#"}),"斐波那契数列"]}),"\n",(0,c.jsx)(e.p,{children:"0 1 1 2 3 5 即后一位为前两位的和"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"位置是0的数列为零"}),"\n",(0,c.jsx)(e.li,{children:"1和2的斐波那契数为1"}),"\n",(0,c.jsx)(e.li,{children:"n > 2的数列为： (n -1) + (n - 2)"}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",meta:"",children:"// 递归\nfunction fibonacciRecursive(num) {\n  if (num < 1) return 0;\n  if (num === 1 || num === 2) return 1;\n  return fibonacciRecursive(num - 1) + fibonacciRecursive(num - 2);\n}\n\n\n// 迭代\nfunction fibonacciIterative(num) {\n  if (num < 1) return 0;\n  if (num === 1 || num === 2) return 1;\n\n  let res = 0;\n  let f1 = 0;\n  let f2 = 1;\n  //   正向迭代 初始化为0，所以迭代次数为：位数 - 1\n  for (let index = 0; index < num - 1; index++) {\n    res = f1 + f2;\n    f1 = f2;\n    f2 = res;\n  }\n\n  return res;\n}\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"记忆化的fibonacci",children:[(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#记忆化的fibonacci",children:"#"}),"记忆化的fibonacci"]}),"\n",(0,c.jsx)(e.p,{children:"主要用一个数据进行结果的缓存，memo。减少计算次数，从而提高效率"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",meta:"",children:"function fibonacciMemoization(n) {\n  const memo = [0, 1]; // {1}\n  const fibonacci = (n, memo) => {\n    if (memo[n] != null) return memo[n]; // {2}\n    return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)); // {3}\n  };\n  return fibonacci(n, memo);\n}\n"})}),"\n",(0,c.jsxs)(e.h2,{id:"总结",children:[(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"性能层面\n递归和迭代相比并不具有性能优势。有些情况下还不如迭代。"}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"优点\n代码量少，容读"}),"\n"]}),"\n"]})]})}(r=globalThis).__RSPRESS_PAGE_META||(r.__RSPRESS_PAGE_META={}),globalThis.__RSPRESS_PAGE_META["%2Fhome%2Frunner%2Fwork%2Fleet-code%2Fleet-code%2Fdocs%2Fzh%2Fguide%2Fbook%2Frecursive.mdx"]={toc:[{id:"阶乘",text:"阶乘",depth:2},{id:"斐波那契数列",text:"斐波那契数列",depth:2},{id:"记忆化的fibonacci",text:"记忆化的fibonacci",depth:3},{id:"总结",text:"总结",depth:2}],title:"第9章 递归",frontmatter:{}};var t=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=Object.assign({},(0,s.useMDXComponents)(),n.components).wrapper;return e?(0,c.jsx)(e,Object.assign({},n,{children:(0,c.jsx)(a,n)})):a(n)}}}]);