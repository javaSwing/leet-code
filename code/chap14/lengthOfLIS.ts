/**
 * 最长递增子序列
 * @link https://leetcode.cn/problems/longest-increasing-subsequence/
 */

/**
 * O(n^2)
 *
 * 思路：
 * 先说下，拿到题的最初想法。我最初的想法是：两次递归，声明一个数组。把递增的结果放进去，然后返回该数组的长度。但是该方法并没有写出来。所以不要尝试
 *
 * 正确的解题思路：
 * 1. 使用dp进行数组，与原数组长度相同。初始化都为1。该数组代表，dp[i]以num[i]结尾时，最长的递增子序列。假设都为1
 * 2. 外层循环进行正常的循环数组，注意是小于等于数组的长度
 * 3. 内层循环是从0开始，到目前外层数组的索引长度截止
 * 4. 如果外层的位置值 > 内层的位置值。则当前外层索引的dp[i] = d[j] + 1与当前d[i]的值中的最大值
 *
 * 为什么是dp[j] + 1k呢？因为需要把当前i的数目加上去，因为 > 的成立，肯定要+1
 *
 * 注：命令实现的代码写多了，就会有一个思路：从要得出的结果来反推函数的实现，就像我刚拿到题的想法一样。
 * 有时候这类题的可以换一种思路：声明一个与原数组相同的值，用对应的索引值来记录对应的值。最后取最大也是一个思路。
 * 总结：不一定返回的是真实的数组，也可以是寄存在一个数组中的对应值国
 *
 */
export const lengthOfLIS = (nums: number[]) => {
  const dp = new Array(nums.length).fill(1);

  for (let i = 0; i <= nums.length; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[j] + 1, dp[i]);
      }
    }
  }
  return Math.max(...dp);
};
